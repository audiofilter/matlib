function [out] = quantize(x,no_bits,flag)

% QUANTIZE .... Maps an analog sequence sequence into a quantized sequence.
%
%	QUANTIZE(X,N) Takes the analog input sequence (analog within the limits
%		of machine accuracy) and quantizes each element of X using an 
%		N-bit, mid-riser type uniform quantizer. Number of quantization 
%		levels is 2^N, where 1 <= N <= 8.
%		The quantizer range is restricted to the interval [-1, 1].
%
%		If non-uniform quantization is desired, the input sequence has 
%		to be first companded by applying the M-function MU_LAW.
%		For example the sequence XCQ generated by using 
%		QUANTIZE(MU_LAW(X,255),8) will be the MU-LAW companded
%		(with MU=255) 256-level quantized sequence.
%
%	QUANTIZE(X,N,'scale') overrides the default input magnitude range of
%		[-1, 1] and adjusts quantizer range to [-K, K], where 
%		K = max( |x(t)| ).
%
%	QUANTIZE(X,N,'no_scale') is equivalent to QUANTIZE(X,N).
%		
%	See also MU_LAW, QUANT_EF and QUANT_CH.

%	AUTHORS : M. Zeytinoglu & N. W. Ma
%             Department of Electrical & Computer Engineering
%             Ryerson Polytechnic University
%             Toronto, Ontario, CANADA
%
%	DATE    : August 1991.
%	VERSION : 1.0

%===========================================================================
% Modifications history:
% ----------------------
%	o   Added 'scaling' input parameter. 06.06.91 MZ
%	o   Changed input N to "quantization levels". 06.17.91 MZ
%	o   Changed input N to "bits/sample". 06.19.91 MZ
%	o   Added "checking"  11.30.1992 MZ
%	o	Tested (and modified) under MATLAB 4.0/4.1 08.16.1993 MZ
%===========================================================================

global START_OK;
global BELL;
global WARNING;

check;

if ((nargin ~= 3) & (nargin ~= 2))
   error(eval('eval(BELL),eval(WARNING),help quantize'));
   return;
end   
no_qs = 2^no_bits;
if ( (no_bits > 8) | (no_qs < 1) | (no_bits ~= fix(no_bits)) )
   error('Number of bits/sample must be an integer between 1 and 8.');
end

%---------------------------------------------------------------------------
%	Input parameter set-up
%---------------------------------------------------------------------------

scale_flag_default = 'no_scale';

if (nargin == 2)
   scale_flag = scale_flag_default; 
elseif (nargin == 3)
   scale_flag = flag; 
end

%---------------------------------------------------------------------------
%	To prevent overload distortion check for overload conditions
%	and normalize if necessary: |x(n)| <= 1.
%---------------------------------------------------------------------------
if strcmp(scale_flag, 'scale')
   scale_factor = max( abs(max(x)), abs(min(x)) ); 
   in = x/max(abs(max(x)),abs(min(x))); 
elseif strcmp(scale_flag, 'no_scale')
   scale_factor = 1;
   in = x;
else
   error('Unknown scaling option.');
end

%---------------------------------------------------------------------------
%	Set up output vector, quantization step size, QSTEP, and
%	quantization range values RANGE, and quantized values Q,
%	for a mid-riser type uniform quantization.
%---------------------------------------------------------------------------

qstep = 2/no_qs;

for ii = 1:no_qs
   range(ii) = -1 + (ii-1)*qstep;
end

%---------------------------------------------------------------------------
%	Now check for x(n) values with respect to RANGE parameters and
%	assign appropriate quantized values, such that if
%	(RANGE(i) <= x(n) < RANGE(i+1)) then  x(n) --> xq(n) = Q(i).
%---------------------------------------------------------------------------

out = zeros(size(in));
for ii = no_qs:(-1):1
    out = out + (in>=range(ii));
end

out = out - 1;
out = (out) * qstep + (-1 + qstep/2);
out = scale_factor * out;

if strcmp(scale_flag, 'no_scale')
   out = limiter(out,(-1+qstep/2),(1-qstep/2));
end

